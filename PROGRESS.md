# 项目总结与技术概览

本文档旨在全面总结本项目的已完成功能、技术架构、核心设计思想及关键算法实现，作为项目达到稳定交付状态的最终技术沉淀。

---

## 一、软件需求与已完成功能

本项目旨在开发一个纯前端的在线编辑工具，用于可视化地编辑和管理复杂的 `preset.json` 文件，核心目标是降低其维护难度。目前，应用已完成所有核心需求，提供了一个功能完整、体验流畅、界面美观的 Prompt 预设编辑与管理工具。

### 核心编辑功能

- **智能解析与加载**: 应用启动时自动加载本地 `preset.example.json`，并能精确解析其复杂的嵌套数据结构，特别是针对 `character_id: 100001` 的 `prompt_order`。
- **可视化排序**: 用户可在中间编辑区通过拖拽 Prompt 卡片，直观地修改 `prompt_order` 顺序。
- **Prompt 管理**:
  - **启用/禁用**: 通过美观的 `Switch` 开关，可以方便地切换 Prompt 的 `enabled` 状态，状态会以不同的背景色明确区分。
  - **隐藏**: 可将 Prompt 从当前编辑序列中暂时移除，但保留在左侧库中以备后用。
  - **删除**: 可从 `prompts` 库中永久删除一个 Prompt。
  - **新建**: 在左侧库工具栏提供“添加”按钮，生成占位 Prompt 并添加到编辑序列顶部，同时自动导航到新创建的 Prompt。
  - **多选与批量删除**: 左侧库支持多选模式，可批量删除选中的 Prompt。
  - **添加到编辑区**: 左侧库中的 Prompt 可通过点击图标添加到编辑序列顶部，并自动导航。
- **详情查看与编辑**: 单击卡片可在右侧边栏查看并**实时编辑** Prompt 的详细信息（名称、内容），修改会立即同步到编辑器。
- **导航**: 无论从左侧库还是右侧宏详情点击 Prompt，中间编辑器都会自动滚动并高亮显示目标 Prompt。

### 宏 (Macro) 系统

- **自动解析与分析**: 应用能自动扫描所有 Prompt，解析出 `{{...}}` 宏，并建立变量定义 (`setvar`) 与引用 (`getvar`) 的完整关系图。
- **差异化高亮**:
  - 宏会根据其类型（变量、注释、随机等）以不同颜色高亮显示。
  - 未被定义的“悬空”变量引用会以醒目的红色波浪线进行警告。
- **变量引用追踪**: 单击任意一个变量宏 (`setvar` 或 `getvar`)，所有相关的宏实例都会被高亮，同时右侧边栏会显示该变量的所有定义位置和所有引用位置列表，实现了类似 IDE 的 "Find Usages" 功能。

### 变量管理页面

- **集中管理**: 右侧边栏新增“变量”选项卡，列出当前所有已定义的变量（跨 Prompt）。
- **快速定位**: 点击变量列表中的变量名，可自动切换到“详情”选项卡，并高亮显示该变量的所有定义和引用。
- **状态图标与提示**: 变量列表中的每一项现在会根据其状态显示不同的图标：
  - 黄色感叹号图标表示变量已定义但未被引用。
  - 红色问号图标表示变量未定义但被引用。
  - 悬停时会显示详细的提示信息，使用 `floating-vue` 的 `v-tooltip` 指令实现，确保提示不会被父容器裁剪。
- **重命名工具**: 提供一个安全的变量重命名工具，确保新名称验证更加严格（非空、无冲突、无非法字符），并在所有 `setvar` 和 `getvar` 宏中同步更新变量名。

### UI/UX 与文件操作

- **现代化 UI**: 基于 **Headless UI** 和 **Heroicons** 进行了全面的 UI 重构，界面美观、交互流畅。
- **可调节布局**: 使用 `splitpanes` 库实现了左、中、右三栏布局的宽度可自由拖拽调整，提升工作区灵活性。
- **无障碍弹窗**: 导入/导出功能使用了 Headless UI 的 `Dialog` 组件，提供了完美的焦点管理、键盘导航和过渡动画，符合无障碍标准。模态窗口背景为半透明。
- **优雅的交互组件**: Prompt 卡片上的操作被整合进 `Menu` 下拉菜单，核心的启用/禁用功能由 `Switch` 组件提供，大大提升了界面的整洁度和用户体验。
- **文件操作**:
  - **导入**: 支持通过弹窗粘贴新的 JSON 内容，并将其加载到编辑器中。
  - **导出**: 可随时将当前编辑状态生成为格式化好的 JSON，并一键复制到剪贴板。
  - **重置**: 支持一键将所有编辑内容恢复到应用初次加载时的原始状态。
- **搜索过滤**: 左侧 Prompt Library 顶部添加搜索框，可按名称或 ID 过滤列表，搜索时自动重置多选状态。
- **美化滚动条**: 全局滚动条样式优化，更纤细、美观，与整体设计协调。

---

## 二、项目架构与核心设计

### 技术栈

- **构建工具**: Vite
- **核心框架**: Vue 3 (Composition API with `<script setup>`)
- **状态管理**: Pinia
- **UI 框架**: Tailwind CSS v4 (通过 Vite 插件集成)
- **UI 组件库**: Headless UI (Vue)
- **图标库**: Heroicons (Vue)
- **布局**: Splitpanes
- **拖拽**: vuedraggable

### 核心设计思想：状态驱动的 UI

本项目严格遵循**单一可信源 (Single Source of Truth)** 的设计原则。所有与 `preset.json` 相关的数据，包括 `prompts` 库、`promptOrder` 排序、宏分析结果、UI 状态（如选中的 Prompt、活跃的侧边栏选项卡）等，全部集中在 **Pinia** 的 `presetStore` 中进行管理。

- **数据流**: 用户的任何操作（如拖拽、点击按钮、输入文本）都会派发 (dispatch) 一个 **Action** 到 Store。Action 负责修改 **State**。Vue 组件则通过**计算属性 (Getters)** 响应式地订阅 State 的变化，并自动更新视图。这种模式使得数据流清晰、单向且可预测。组件本身几乎不包含任何业务逻辑，只负责“展示”和“触发”，极大地降低了代码的耦合度，提升了可维护性。

### 组件化结构

应用被拆分为一系列高内聚、低耦合的 Vue 组件，职责分明：

- `App.vue`: 根组件，负责集成主布局、工具栏和模态框。
- `Toolbar.vue`: 顶部工具栏，处理导入/导出/重置事件的派发。
- `JsonImportModal.vue` / `JsonExportModal.vue`: 基于 Headless UI `Dialog` 的功能性弹窗。
- `EditorView.vue`: 中间编辑区，集成 `vuedraggable`，管理 Prompt 列表的渲染和排序。
- `PromptCard.vue`: 核心的 Prompt 卡片，集成了 Headless UI 的 `Switch` 和 `Menu`，并负责渲染 Prompt 内容。
- `MacroRenderer.vue`: 宏渲染器，是宏系统的视觉末端，根据宏类型和状态显示不同样式。
- `RightSidebar/index.vue`: 右侧边栏的入口组件，使用 Headless UI `TabGroup` 管理“详情”和“变量”选项卡。
- `RightSidebar/DetailsView.vue`: 显示选中 Prompt 或宏的详情。
- `RightSidebar/VariableManager.vue`: 变量管理页面，列出所有变量并提供重命名工具。
- `LeftSidebar/PromptLibrary.vue`: 左侧边栏，展示所有 prompts，包含搜索和管理工具栏。
- `LeftSidebar/PromptLibraryItem.vue`: 左侧边栏中的单个 prompt 条目，包含多选和添加到编辑区的功能。

---

## 三、关键代码算法解析

### 1. `prompt_order` 的精确解析与更新

为了保证编辑器只操作 `character_id` 为 `100001` 的数据，同时不破坏文件中其他角色的配置，我们实现了精确的读写逻辑。

- **解析 (`parseFromJson`)**: 在解析 JSON 时，代码会遍历 `prompt_order` 数组，使用 `find` 方法定位到 `character_id` 为 `100001` 的对象。然后，只提取该对象内部的 `order` 数组作为编辑器的数据源。同时，`order` 数组中的 `enabled` 状态会被同步到 `prompts` 库中对应的 Prompt 对象上，确保状态的统一。
- **导出 (`finalJson` Getter)**: 在生成最终 JSON 时，代码会先深拷贝原始 JSON 结构。然后，同样定位到 `character_id: 100001` 的对象，并用当前编辑器中的 `promptOrder` 状态去**覆盖**其 `order` 字段。`prompt_order` 数组中的任何其他对象都保持原样，从而实现了安全、精确的“原地更新”。

### 2. 宏变量关系图的构建 (`analyzeMacros`)

这是宏系统的核心算法，它通过一个高效的两步过程来构建变量的定义-引用关系图。

1.  **初次扫描与分类**:
    - 使用正则表达式 `/{{\s*(.*?)\s*}}/gs` 遍历所有 Prompt 的 `content` 字符串，捕获所有宏。
    - 在循环中，对每个宏的内容进行解析，判断其类型。如果是 `setvar`，则在一个临时的 `newVariables` 对象中记录下变量名和其定义的 `promptId` 列表。如果是 `getvar`，则将其变量名和所在的 `promptId` 存入一个临时的 `getVarRefs` 数组。

2.  **二次处理与关联**:
    - 遍历 `getVarRefs` 数组。
    - 对于每一个 `getvar` 引用，去 `newVariables` 对象中查找是否存在对应的定义。如果存在，就将当前的 `promptId` 添加到该变量的 `referencedIn` 数组中。如果不存在，就将这个引用记录到 `unresolvedVariables` 数组中，以便 UI 对其进行警告。

这个算法确保了在 O(N) 的时间复杂度内（N 为所有 Prompt 的总字符数）完成了所有宏的分析，性能高效，且逻辑清晰。最终产出的 `variables` 和 `unresolvedVariables` 对象为所有后续的交互功能（高亮、详情展示、变量管理）提供了坚实的数据基础。

### 3. 变量重命名 (`renameVariable`)

这是一个关键的高级功能，其算法确保了重命名的安全性和完整性：

1.  **合法性与冲突检查**: 在执行重命名之前，会严格检查新变量名是否为空、是否包含空格或特殊字符，以及是否与现有变量名冲突。任何不符合规则的情况都会被阻止。
2.  **全局替换**: 如果验证通过，算法会遍历所有 Prompt 的 `content` 字段。使用正则表达式（精确匹配 `setvar::` 和 `getvar::` 后面的变量名）进行全局替换，确保所有定义和引用该变量的地方都被同步更新。
3.  **重新分析宏**: 在内容修改完成后，立即调用 `analyzeMacros()` action。这会强制系统重新扫描所有 Prompt，更新 `variables` 和 `unresolvedVariables` 状态，确保宏系统的数据始终与最新的 Prompt 内容保持一致。

### 4. 宏解析与渲染一致性

整个应用的宏解析和渲染逻辑已经统一，确保了跨行宏、包含特殊字符的宏内容能够被正确处理：

1. **解析逻辑**: `presetStore.js` 使用正则表达式 `/{{\s*(.*?)\s*}}/gs` 来捕获所有宏，支持跨行匹配并确保无嵌套。
2. **内容分割**: `PromptCard.vue` 使用正则表达式 `/({{\s*.*?\s*}})/gs` 分割普通文本和宏，确保跨行宏能够正确识别。
3. **宏渲染**: `MacroRenderer.vue` 使用字符串查找方法解析宏类型和变量名，确保复杂内容能够正确渲染。

这些改动确保了宏系统在解析、分割和渲染的各个环节都能正确处理复杂的宏内容。
