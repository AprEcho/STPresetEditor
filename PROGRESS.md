# 项目总结与技术概览

本文档旨在全面总结本项目的已完成功能、技术架构、核心设计思想及关键算法实现，作为项目达到稳定交付状态的最终技术沉淀。

---

## 一、软件需求与已完成功能

本项目旨在开发一个纯前端的在线编辑工具，用于可视化地编辑和管理复杂的 `preset.json` 文件，核心目标是降低其维护难度。目前，应用已完成所有核心需求，提供了一个功能完整、体验流畅、界面美观的 Prompt 预设编辑与管理工具。

### 核心编辑功能

- **智能解析与加载**: 应用启动时自动加载本地 `preset.example.json`，并能精确解析其复杂的嵌套数据结构，特别是针对 `character_id: 100001` 的 `prompt_order`。
- **可视化排序**: 用户可在中间编辑区通过拖拽 Prompt 卡片，直观地修改 `prompt_order` 顺序。
- **Prompt 管理**:
  - **启用/禁用**: 通过美观的 `Switch` 开关，可以方便地切换 Prompt 的 `enabled` 状态，状态会以不同的背景色明确区分。
  - **隐藏**: 可将 Prompt 从当前编辑序列中暂时移除，但保留在左侧库中以备后用。
  - **删除**: 可从 `prompts` 库中永久删除一个 Prompt。
  - **新建**: 在左侧库工具栏提供“添加”按钮，生成占位 Prompt 并添加到编辑序列顶部，同时自动导航到新创建的 Prompt。
  - **多选与批量删除**: 左侧库支持多选模式，可批量删除选中的 Prompt。
  - **添加到编辑区**: 左侧库中的 Prompt 可通过点击图标添加到编辑序列顶部，并自动导航。
- **详情查看与编辑**: 单击卡片可在右侧边栏查看并**实时编辑** Prompt 的详细信息（名称、内容），修改会立即同步到编辑器。
- **导航**: 无论从左侧库还是右侧宏详情点击 Prompt，中间编辑器都会自动滚动并高亮显示目标 Prompt。

### 宏 (Macro) 系统

- **自动解析与分析**: 应用能自动扫描所有 Prompt，解析出 `{{...}}` 宏，并建立变量定义 (`setvar`) 与引用 (`getvar`) 的完整关系图。
- **差异化高亮**:
  - 宏会根据其类型（变量、注释、随机等）以不同颜色高亮显示。
  - 未被定义的“悬空”变量引用会以醒目的红色波浪线进行警告。
- **变量引用追踪**: 单击任意一个变量宏 (`setvar` 或 `getvar`)，所有相关的宏实例都会被高亮，同时右侧边栏会显示该变量的所有定义位置和所有引用位置列表，实现了类似 IDE 的 "Find Usages" 功能。

### 变量管理页面

- **集中管理**: 右侧边栏新增“变量”选项卡，列出当前所有已定义的变量（跨 Prompt）。
- **快速定位**: 点击变量列表中的变量名，可自动切换到“详情”选项卡，并高亮显示该变量的所有定义和引用。
- **状态图标与提示**: 变量列表中的每一项现在会根据其状态显示不同的图标：
  - 黄色感叹号图标表示变量已定义但未被引用。
  - 红色问号图标表示变量未定义但被引用。
  - 悬停时会显示详细的提示信息，使用 `floating-vue` 的 `v-tooltip` 指令实现，确保提示不会被父容器裁剪。
- **重命名工具**: 提供一个安全的变量重命名工具，确保新名称验证更加严格（非空、无冲突、无非法字符），并在所有 `setvar` 和 `getvar` 宏中同步更新变量名。

### UI/UX 与文件操作

- **现代化 UI**: 基于 **Headless UI** 和 **Heroicons** 进行了全面的 UI 重构，界面美观、交互流畅。
- **可调节布局**: 使用 `splitpanes` 库实现了左、中、右三栏布局的宽度可自由拖拽调整，提升工作区灵活性。
- **无障碍弹窗**: 导入/导出功能使用了 Headless UI 的 `Dialog` 组件，提供了完美的焦点管理、键盘导航和过渡动画，符合无障碍标准。模态窗口背景为半透明。
- **优雅的交互组件**: Prompt 卡片上的操作被整合进 `Menu` 下拉菜单，核心的启用/禁用功能由 `Switch` 组件提供，大大提升了界面的整洁度和用户体验。
- **文件操作**:
  - **导入**: 支持通过弹窗粘贴新的 JSON 内容，并将其加载到编辑器中。
  - **导出**: 可随时将当前编辑状态生成为格式化好的 JSON，并一键复制到剪贴板。
  - **重置**: 支持一键将所有编辑内容恢复到应用初次加载时的原始状态。
- **搜索过滤**: 左侧 Prompt Library 顶部添加搜索框，可按名称或 ID 过滤列表，搜索时自动重置多选状态。
- **美化滚动条**: 全局滚动条样式优化，更纤细、美观，与整体设计协调。

---

## 二、项目架构与核心设计

### 技术栈

- **构建工具**: Vite
- **核心框架**: Vue 3 (Composition API with `<script setup>`)
- **状态管理**: Pinia
- **UI 框架**: Tailwind CSS v4 (通过 Vite 插件集成)
- **UI 组件库**: Headless UI (Vue)
- **图标库**: Heroicons (Vue)
- **布局**: Splitpanes
- **拖拽**: vuedraggable

### 核心设计思想：状态驱动的 UI

本项目严格遵循**单一可信源 (Single Source of Truth)** 的设计原则。所有与 `preset.json` 相关的数据，包括 `prompts` 库、`promptOrder` 排序、宏分析结果、UI 状态（如选中的 Prompt、活跃的侧边栏选项卡）等，全部集中在 **Pinia** 的 `presetStore` 中进行管理。

- **数据流**: 用户的任何操作（如拖拽、点击按钮、输入文本）都会派发 (dispatch) 一个 **Action** 到 Store。Action 负责修改 **State**。Vue 组件则通过**计算属性 (Getters)** 响应式地订阅 State 的变化，并自动更新视图。这种模式使得数据流清晰、单向且可预测。组件本身几乎不包含任何业务逻辑，只负责“展示”和“触发”，极大地降低了代码的耦合度，提升了可维护性。

### 组件化结构

应用被拆分为一系列高内聚、低耦合的 Vue 组件，职责分明：

- `App.vue`: 根组件，负责集成主布局、工具栏和模态框。
- `Toolbar.vue`: 顶部工具栏，处理导入/导出/重置事件的派发。
- `JsonImportModal.vue` / `JsonExportModal.vue`: 基于 Headless UI `Dialog` 的功能性弹窗。
- `EditorView.vue`: 中间编辑区，集成 `vuedraggable`，管理 Prompt 列表的渲染和排序。
- `PromptCard.vue`: 核心的 Prompt 卡片，集成了 Headless UI 的 `Switch` 和 `Menu`，并负责渲染 Prompt 内容。
- `MacroRenderer.vue`: 宏渲染器，是宏系统的视觉末端，根据宏类型和状态显示不同样式。
- `RightSidebar/index.vue`: 右侧边栏的入口组件，使用 Headless UI `TabGroup` 管理“详情”和“变量”选项卡。
- `RightSidebar/DetailsView.vue`: 显示选中 Prompt 或宏的详情。
- `RightSidebar/VariableManager.vue`: 变量管理页面，列出所有变量并提供重命名工具。
- `LeftSidebar/PromptLibrary.vue`: 左侧边栏，展示所有 prompts，包含搜索和管理工具栏。
- `LeftSidebar/PromptLibraryItem.vue`: 左侧边栏中的单个 prompt 条目，包含多选和添加到编辑区的功能。

---

## 三、关键代码算法解析

### 1. `preset.json` 的精确读写

为保证编辑器只操作特定角色 (`character_id: 100001`) 的数据，同时不破坏文件中其他角色的配置，我们实现了精确的读写逻辑。

- **解析 (`parseFromJson`)**: 加载时，代码会遍历 `prompt_order` 数组，定位到目标角色，并只提取其 `order` 数组作为编辑器的数据源。同时，`order` 中的 `enabled` 状态会被同步到 `prompts` 库中对应的 Prompt 对象上，确保状态统一。
- **导出 (`finalJson` Getter)**: 导出时，代码会先深拷贝原始 JSON 结构，再次定位到目标角色，并仅用当前编辑器的 `promptOrder` 状态去覆盖其 `order` 字段，从而实现安全、精确的“原地更新”。此外，在导出 `prompts` 数组前，会先将其内部用于优化的 `macros` 临时属性移除，确保输出的 JSON 纯净且兼容。

### 2. 统一宏分析引擎 (`analyzeAllMacros`)

宏系统是编辑器的核心，其关键在于 `analyzeAllMacros` 这个统一分析函数。为实现高性能和高可维护性，该函数采用“一次解析，处处使用”的原则，并将分析范围严格限定在用户当前可见的 `prompt_order` 序列中，确保分析结果与用户预期完全一致。

**核心原则：聚焦 `prompt_order`**

分析流程严格遵循以 `prompt_order` 为中心的原则。任何不在 `prompt_order` 数组中的 Prompt（即被“隐藏”的 Prompt）都不会被纳入宏分析的范围。这确保了变量的定义、引用和实时值计算都只在当前有效的上下文中进行。

**核心数据结构：`macroData` 对象**

分析流程的第一步，是将 `prompt_order` 中所有 Prompt 内容里的宏文本（`{{...}}`）解析为一个标准化的 `macroData` 对象。这个对象是整个系统消费的最小单元，它被直接附加到 `presetStore` 中对应的 Prompt 对象上。

`macroData` 对象的结构如下：

| 字段      | 类型             | 描述                                                         |
| :-------- | :--------------- | :----------------------------------------------------------- |
| `id`      | `string`         | 宏实例的唯一 ID，由 `promptId` 和其在内容中的起始位置构成。  |
| `full`    | `string`         | 完整的宏文本，例如 `{{setvar::x::10}}`。                     |
| `type`    | `string`         | 解析后的宏类型，如 `setvar`, `getvar`, `comment`, `random`。 |
| `varName` | `string \| null` | 宏关联的变量名（如果适用）。                                 |
| `value`   | `string \| null` | `setvar` 宏所设定的值。                                      |
| `params`  | `string[]`       | 其他类型宏的参数列表，例如 `random` 宏的选项。               |

**多阶段分析法 (Multi-Pass Analysis)**

1.  **预处理：清理阶段 (Cleanup Pass)**
    - 在每次分析开始时，系统会先遍历所有 `prompts` 对象，将它们附带的旧 `macros` 数组清空。这确保了被移出 `prompt_order` 的 Prompt 不会携带任何过时的宏信息，保证了状态的纯净。

2.  **第一阶段：结构化解析 (Parsing Pass)**
    - 遍历 `prompt_order` 数组，只对当前序列中的 Prompt 进行处理。
    - 使用正则表达式 `/{{\s*(.*?)\s*}}/gs` 查找其 `content` 中的所有宏，并转换为标准化的 `macroData` 对象。
    - 将生成的 `macroData` 对象数组存放在对应 Prompt 的 `macros` 属性上。

3.  **第二阶段：模拟与分析 (Simulation & Analysis Pass)**
    - 首先，使用 `flatMap` 从 `prompt_order` 中高效地构建出一个包含所有相关宏的扁平化“执行流”数组 (`executionFlowMacros`)。
    - 遍历此执行流，**同时执行**静态分析和运行时模拟：
      - **静态分析**：无条件记录所有 `setvar` 和 `getvar` 的定义与引用信息（包括其所在 Prompt 的 `enabled` 状态），用于构建完整的变量关系图。
      - **运行时模拟**：在同一个循环中，为 `getvar` 宏生成值快照。关键点在于，只有当一个 `setvar` 宏所在的 Prompt 的 `enabled` 状态为 `true` 时，它才被允许更新模拟中的变量状态。这确保了被禁用 Prompt 中的 `getvar` 依然能看到正确的上下文值。

4.  **第三阶段：结果聚合 (Aggregation Pass)**
    - 基于第二阶段收集的完整定义/引用信息，生成最终的 `variables` 和 `unresolvedVariables` 状态，供整个 UI 使用。
    - 将模拟中生成的 `macroStateSnapshots` 提交到 store。

这个设计将重量级的解析工作仅执行一次，后续的模拟和分析都在一个高效的循环中完成，确保了逻辑的清晰、准确和高性能。对于用户输入等高频操作，该函数的调用被 `debounce` (防抖) 处理，避免了不必要的重复计算，保证了 UI 的流畅性。

### 3. 统一的渲染与交互

得益于 `analyzeAllMacros` 生成的结构化数据，下游组件的渲染和交互逻辑得以极大简化。通过 props 逐层传递状态（如 `macroDisplayMode`），保证了组件的纯粹性和可测试性。

- **宏渲染模式**: 编辑器支持“原始模式”和“预览模式”两种渲染方式，由 `presetStore` 中的 `macroDisplayMode` 状态驱动。
  - **原始模式 (Raw Mode)**: 默认模式，所有宏均以其原始文本（`{{...}}`）的形式高亮显示。
  - **预览模式 (Preview Mode)**: `getvar` 宏会被替换为其在当前执行顺序下的真实值，并以特殊样式高亮，以区别于普通文本；`setvar` 和注释宏则被完全隐藏，以提供一个更干净的阅读视图。所有宏在两种模式下均保持可点击，以触发“查找引用”功能。

- **`PromptCard.vue`**: 作为“控制器”组件，它根据当前的 `macroDisplayMode` 状态，智能地决定哪些宏需要被渲染。在预览模式下，它会直接从待渲染列表中过滤掉 `setvar` 和注释宏。

- **`MacroRenderer.vue`**: 作为一个纯粹的“展示”组件，它接收 `macroData` 对象和 `displayMode` 作为 props。它内部包含根据模式切换渲染逻辑：在预览模式下，它会渲染 `getvar` 的值；在原始模式下，则渲染其原始文本。

- **`MacroDetails.vue`**: 该组件用于展示变量的定义和引用列表。它消费 `variables` state 中包含 `enabled` 状态的数组，从而能通过简单的 `:class` 绑定，将来自未启用 Prompt 的引用以灰色样式进行区分，提升了用户体验。

这种自顶向下的数据流确保了宏的解析与渲染逻辑的绝对一致，极大地提升了代码的可维护性。

### 4. 变量重命名 (`renameVariable`)

这是一个关键的高级功能，其算法确保了重命名的安全性和完整性：

1.  **合法性与冲突检查**: 在执行重命名之前，会严格检查新变量名是否为空、是否包含空格或特殊字符，以及是否与现有变量名冲突。任何不符合规则的情况都会被阻止。
2.  **全局替换**: 如果验证通过，算法会遍历所有 Prompt 的 `content` 字段。使用正则表达式（精确匹配 `setvar::` 和 `getvar::` 后面的变量名）进行全局替换，确保所有定义和引用该变量的地方都被同步更新。
3.  **重新分析宏**: 在内容修改完成后，立即调用 `analyzeAllMacros()` action，强制系统重新扫描所有 Prompt，更新整个宏系统状态。
